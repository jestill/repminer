#!/usr/bin/perl -w
#-----------------------------------------------------------+
#                                                           |
# RepMiner : RepPipe.pl                                     |
#                                                           |
#-----------------------------------------------------------+
#  AUTHOR: James C. Estill                                  |
# CONTACT: jestill_at_sourceforge.net                       |
# STARTED: 04/05/2007                                       |
# UPDATED: 04/06/2007                                       |
#                                                           |
# SHORT DESCRIPTION:                                        |
#  Repeat analysis pipeline. Given a fasta file, does the   |
#  basic analysis required to produce the files needed for  |
#  Since I am the only one that will be using this, I am    |
#  setting this up explicity for mysql and options that are |
#  only available on my machine.                            |
#                                                           |
# DEPENDENCIES:                                             |
#  -BioPERL                                                 |
#  -NCBI BLAST                                              |
#  -GD                                                      |
#  -MySQL                                                   |
#                                                           |
# USAGE:                                                    |
#  RepPipe.pl -h For full usage                             |
#                                                           |
#-----------------------------------------------------------+
# TODO:
# []  Check if the entire set of databases can be passed to the
#     blast command and provide output that can still be
#     parsed by database.
# []  Do -m 8 output and parsing of the Repeat databases
#

print "The RepPipe program has started.\n\n";

=head1 Includes
=cut
#-----------------------------+
# INCLUDES                    |
#-----------------------------+
use Cwd;                       # Get the current working directory
use strict;                    # Lets see what this does
use DBI();                     # Database interface
use Getopt::Std;               # Get options from the command line

=head1 Variable Scope
=cut

#-----------------------------+
# HARD CODED VARIABLES        |
#-----------------------------+
my $DbDir = "/home/jestill/blast/repeats/";
my $BlProg = "blastn";
my $BlSuf = "-a 2";

#-----------------------------+
# GENERAL PROGRAM VARIABLES   |
#-----------------------------+
my $CurDir;                    # The current working directory
$CurDir = cwd();               # Use the cwd command to get the CurDir
my $InFastaFile;               # Input FASTA file
my $OutDir;                    # Output directory
my $RootName;                  # Root name of the input fasta file
                               # This name will be used throughout
                               # the output generated by the program.

# Use Pipe* for the following to assure unique var names
my $PipeDB;                    # Database name, 
my $PipeUser;                  # Database user name
my $PipePass;                  # Database password

#-----------------------------+
# ALL-BY-ALL BLAST            |
#-----------------------------+
my $AllByAll;                  # Path to AllByAll blast output file
my $A_MinQryLen;               # Minimum query length for all by all blast
my $A_MinScore;                # Minimum Bit Score for all by all blast
my $A_MaxE;                    # Maximum E value for all by all blast
my $A_BlSuf;                   # AllByAll Blast suffix

my $RepeatDb;                  # Path to the repeat database to blast against
my $BlastDbFile;
my $ResultCount = 0;           # Result count for BLAST
my $MinHitLen = "20";          # The minimum hit length to consider
my @BlastMatrix;               # Array to hold the blast results
my $BlastResult;               # The BLAST Result 
my $BlastHit;                  # Individual BLAST hit
my $HSP;                       # BLAST HSP Result
my $BlastDB;                   # The blast database that was queried
my $HitId;                     # Unique ID of the BLAST hit
my $SpHInfo;                   # Information related to the BLAST hit
my @HitDesc;                   # Initially split the hit description
my @HitInfo;                   # Array to hold the split of the hit info

my $RepDbCmd;                  # List of repeat databases from the command line
my @RepDb;                     # List of nucleotide repeat databases
my $RunRepBlast;               # BOOLEAN. Run the repeat blast
my $ProcNum = "0";             # Initialize process number to zero
my $AllRepPath;                # Path to the concantenated output of repeat blasts
my $OutPath;                   # Path used for each of the repeat databases

#-----------------------------+
# DATABASE COMMANDS           |
#-----------------------------+

=head1 Get Command Line Options
=cut
my $Usage = "USAGE:\n".
    "RepPipe.pl -i FileToAnalyze.fasta -r RepElementDb\n". 
    "-o OutputDir -u UserName -d DatabaseName-Q\n\n".
    "+-----------------------------------------------------------+\n".
    "| REQUIRED ARGUMENTS                                        |\n".
    "+-----------------------------------------------------------+\n".
    " -i The path of the fasta file to analyze [String]\n".
    " -o The path of the output directory [String]\n".
    "    You should include / at the end of the string.\n".
    " -u The user name for connection to the database [String]\n".
    " -b The database name to use for the database connection. [String]\n".
    "    This database MUST already exist in you MySQL database.\n".
    " -p Database password [String]\n".
    " -e Max e value for all-by-all BLAST.\n".
    " -H Show help messsage. [Boolean Flag]\n".
    " -s All by All blast suffix [String]\n".
    "    Example -a2\n".
    " -r Repeat database to blast against [String]\n".
    "    NOTE Just give database name, not full path.".
    "    Comma separated list possible, ie:\n".
    "    \'SanMiguel,RepDb\'\n".
    " -B Create database if it does not exist [Boolean Flag]".
    "  OR\n".
    " -Z Config file that provides the above information. [String]\n".
    "    CURRENTLY NOT IMPLEMENTED IN RepPipe.pl\n".
    "\n".
    "jabablast.pl -H TO GET FULL ARGUMENTS LIST.\n";

my %Options;
getopts('i:o:u:b:e:p:r:s:HBR', \%Options);

$InFastaFile = $Options{i};
# I changed my mind here, all files will be placed in the
# directory that the initial fasta file is in
#$OutDir = $Options{o} || $CurDir; # Outdir given at cmd line or 
$OutDir = $Options{o}; # Outdir given at cmd line or 
$PipeDB = $Options{b} ||
    die "ERROR:\n$Usage\n";
$PipeUser = $Options{u} ||
    die "ERROR:\n$Usage\n";
$PipePass = $Options{p};

$A_MaxE = $Options{e} ||
    "0.0000000001";    

$RepDbCmd = $Options{r};

my $Help = $Options{h};

=head1 Main program body
=cut

#-----------------------------+
# GET THE PASSWORD IF NOT     |
# GIVEN AT THE COMMAND LINE   |
#-----------------------------+
#unless ($PipePass)
#{
#    print "\nPassword for $DbUserName\n";
#    system('stty', '-echo') == 0 or die "can't turn off echo: $?";
#    $PipePass = <STDIN>;
#    system('stty', 'echo') == 0 or die "can't turn on echo: $?";
#    chomp $PipePass;
#}    

#-----------------------------+
# PRINT HELP                  |
#-----------------------------+
# If the user request help with -H flag, print\
# help message and exit the program
if ($Help)
{
    &PrintHelp;
    exit;
}


#-----------------------------+
# GET THE ROOT NAME OF THE    |
# INPUT FILE                  |
#-----------------------------+
if ($InFastaFile =~ /(.*).fasta/)
{
    my $FilePath = $1;
    my @SplitPath = split (/\//, $FilePath );
    my $Len = @SplitPath;
    # The length of the array - one to get the max element position
    my $Last = $Len - 1;  
    $RootName = $SplitPath[$Last];
    
    # Get the directory of the fasta file used for input
    # and set this to be the OutDir if the output directory 
    # is not already set in the command line
    unless ($OutDir)
    {
	$OutDir = "/";                # Intialize OutDir with root
	for (my $i=1; $i<$Last; $i++)
	{
	    $OutDir = $OutDir.$SplitPath[$i]."/";
	} # End of for i
    } # End of unelss $OutDir
} else {
    print "Input file does not have the fasta extension\n";
    exit;
} # End of InFastaFile with fasta extension 


#-----------------------------+
# Verify input vars exist     |
#-----------------------------+
unless (-e $InFastaFile)
{
    # Sound alarm and print error msg
    print "\a";
    print "ERROR: The input file not found at\n$InFastaFile\n";
    exit;
}

# CREATE THE OUTPUT DIR IF IT DOES NOT EXIST
unless (-e $OutDir)
{
    mkdir $OutDir;
}

#-----------------------------+
# PRINT VARS TO STDOUT        |
#-----------------------------+
print "Root Name:\n\t$RootName\n";
print "Out Dir:\n\t$OutDir\n";

#-----------------------------+
# ADD NUMBER INDEX TO ALL OF  |
# OF THE FASTA FILES          |
#-----------------------------+
#
my $OutFastaNum = $OutDir.$RootName."_num.fasta";
my $AddNumCmd = "./FastaAddNum.pl -i $InFastaFile -o $OutFastaNum"; 
print "CMD:\n\t$AddNumCmd\n";
# Temp comment out
system ($AddNumCmd);

#-----------------------------+
# CREATE MySQL DATABASE IF IT |
# DOES NOT EXIST              |
#-----------------------------+
print "Checking status of database\n";

my $ShowDb = "mysqlshow -u $PipeUser -p$PipePass";
my @DbList = `$ShowDb`;
chomp( @DbList );

my $DbExists = '0';

# CHECK TO SEE IF THE DATABASE EXISTS
my $IndDb; # Individual database in the mysql database
foreach $IndDb (  @DbList )
{

    if ( $IndDb =~ /$PipeDB/ ) 
   {
	print "\a";
	print "The database does exist.\n";
	$DbExists = '1';
    }
	print $IndDb."\n";
}

# CREATE DB IF IT DOES NOT EXIST
unless ($DbExists)
{
    print "The database does not exist.\n\t$PipeDB\n";
    print "The database will be created.\n\t";
    my $CreateDBCmd = "mysqladmin create $PipeDB -u $PipeUser -p$PipePass";
    system ($CreateDBCmd);
}

#-----------------------------+
# LOAD FASTA FILE TO DATABASE |
#-----------------------------+

# First check that the input file was actually made
if (-e $OutFastaNum)
{
    my $Fasta2DbCmd = "./Fasta2DB.pl -i $OutFastaNum -d $PipeDB".
	" -u $PipeUser -p $PipePass";
    print "CMD:\n\t$Fasta2DbCmd";
# TEMP COMMENT OUT
    system ($Fasta2DbCmd);
} else {
    print "Fasta2DB ERROR: The file could not be found at:\n$OutFastaNum\n";
}

#-----------------------------+
# FORMAT DATABASE FOR BLAST   |
#-----------------------------+
# May need to move to the working directory to format database
print "\nFormat database for:\n\t$OutFastaNum\n";
chdir $OutDir;
if (-e $OutFastaNum)
{
    my $FormatBlastCmd = "formatdb -i $OutFastaNum -p F".
	" -n $RootName -t $RootName";
# TEMP COMMENT OUT
    system ($FormatBlastCmd);
} else {
    print "RepMiner Error: Can not find file to format:\n\t$OutFastaNum\n";
    exit;
}

#-----------------------------+
# RUN ALL BY ALL BLAST        |
#-----------------------------+
# 
print "\bRunning All-by-All BLAST.\n";
$BlastDbFile = $OutDir.$RootName.".nin";
if (-e $BlastDbFile )
{
    my $BlastDb = $OutDir.$RootName;
    my $BlastOut = $OutDir.$RootName."_".$RootName.".blo";
    my $BlastCmd = "blastall -p blastn -i $OutFastaNum -d $BlastDb".
	" -e $A_MaxE -m 8 -o $BlastOut";
    print "CMD:\n\t$BlastCmd\n";
# TEMP COMMENT OUT WHILE DEBUG
    system ($BlastCmd);
} else {
    print "RepMiner ERROR: Can not find BLAST database:\n\t".
	"$BlastDbFile";
}

#-----------------------------+
# RUN BLAST AGAINST REPEAT    |
# CLASSIFICATION DATABASE     |
#-----------------------------+
if ($RepDbCmd)
{
    print "\bRunning Rep Class BLASTs\n";

    #-----------------------------+
    # LOAD THE RepDb ARRAY FROM   |
    # THE COMMAND LINE ARGS       |
    #-----------------------------+
    @RepDb = split(/,/, $RepDbCmd);


#    @RepDb = ( 
#	       "gram_rep",            # Gramineae v3.1 repeat database from TIGR
#	       "os_rep",              # Oryza sativa repeat database from TIGR
#	       #"RB_ath",              # A. thaliana repeat database from RepBase
#	       #"RB_ory",              # Oryza sativa repeat database from RepBase
#	       "RB_pln",              # All plants repeat database from RepBase
#	       "TREP_8",              # TREP v.8 database
#	       "Wessler",             # MAGI Wessler Repeat Database
#	       "PM_TIR",              #
#	       "TIGRfab",             # TIGR Fabaceae Repeat Database
#	       "TIGRbras",            # TIGR Brassiceae Repeat Database
#	       "TIGRsol",              # TIGR Solanaceae Repeat Database
#	       "vector",
#	       "zm_rep",              # Zea mays repeat database from TIGR
#	       "SanMiguel"           # SanMiguel Repeat Database
#	       );
    
    # The number of processes is equal to the number of repeat databases
    # that are being blasted against
    my $NumProc = @RepDb;
    

    for $IndDb (@RepDb)
    {
	
	$ProcNum++; # Increment the process number
	print "BLAST Process ".$ProcNum." of ".$NumProc."\n";
	

	# The qry path is the fasta file create above
	my $IndQry = $RootName;
	my $QryPath = $OutFastaNum;
	my $DbPath = $DbDir.$IndDb;
	my $TestFile = $DbPath.".nhr";

	# Added *.rep.* to the file name to allow for a cat command
	# to do a search for *.rep.blo
	# to select the repeat databases
	$OutPath = $OutDir.$IndQry."_".$IndDb.".rep.blo";
	
	#-----------------------------+
	# DOES THE BLAST DB EXIST     |
	#-----------------------------+
	if (-e $TestFile ) 
	{
	    #print "DB: $IndDb exists\n";
	} else {
	    #die "Can not find database:\n$IndDb\n"; 
	    print "\a";
	    print "RepMiner ERROR: Can not find database:\n\t$DbPath";
	}
	
	#-----------------------------+
	# DOES THE BLAST QRY EXIST    |
	#-----------------------------+
	if (-e $QryPath)
	{
	    #print "QRY: $QryPath exists\n";
	} else {
	    die "Can not find qry file:\n$QryPath\n";
	}
	
	#------------------------------+
	# PRINT THE BLAST COMMAND      |
	#------------------------------+
	my $RepBlastCmd = "blastall -p ".$BlProg." -i $QryPath -d $DbPath -o $OutPath $BlSuf";
	print "CMD:\n$RepBlastCmd \n";

	#------------------------------+
	# RUN THE REP BLAST COMMAND    |
	#------------------------------+
	system ($RepBlastCmd);
	
    } # End of for each IndDb in RepDb

    #-----------------------------+
    # IF MORE THEN ONE DATABASE   |
    # WAS BLASTED AGAINST, THEN   |
    # CONCATENATE THE RESULTS     |
    #-----------------------------+
    $AllRepPath = $OutDir.$RootName."_AllRep.blo";
#    if ($NumProc > '1')
#    {
    chdir $OutDir;
    my $CatCmd = "cat *\.rep.blo > ".$RootName."_AllRep.blo";
    print "CMD:\n\t$CatCmd\n";
    system ($CatCmd);
    
    # Clean up the original files
    system ("rm *.rep.blo");
    
#    } else {
#	print "\n";
#	my $CpCmd = "cp $OutPath $AllRepPath";
#	print "CMD:\n\t$CpCmd\n";
#	system ($CpCmd);
#    } # End of if NumProc > 1

} # End of If RunRepBlast
# If more then one blast output file was created, cat them into
# a single file




=head1 SUBFUNCTIONS
=cut
#-----------------------------------------------------------+
# SUBFUNCTIONS                                              |
#-----------------------------------------------------------+
sub PrintHelp 
{

    my $FullUsage = "USAGE:\n".
	"RepPipe.pl -i FileToAnalyze.fasta -r RepElementBlast.blo\n". 
	"-o OutputDir -u UserName -d DatabaseName -Q\n\n".
	"+-----------------------------------------------------------+\n".
	"| REQUIRED ARGUMENTS                                        |\n".
	"+-----------------------------------------------------------+\n".
	" -i The path of the fasta file to analyze [String]\n".
	" -o The path of the output directory [String]\n".
	"    You should include / at the end of the string.\n".
	" -u The user name for connection to the database [String]\n".
	" -b The database name to use for the database connection. [String]\n".
	"    This database MUST already exist in you MySQL database.\n".
	" -p Database password [String]\n".
	" -e Max e value for all-by-all BLAST.\n".
	" -H Show help messsage. [Boolean Flag]\n".
	" -s All by All blast suffix [String]\n".
	"    Example -a2\n".
	" -r Repeat database to blast against [String]\n".
	"    Comma separated list, ie:\n".
	"    \'SanMiguel,RepDb\'\n".
	" -B Create database if it does not exist [Boolean Flag]".
	"  OR\n".
	" -Z Config file that provides the above information. [String]\n".
	"    CURRENTLY NOT IMPLEMENTED IN RepPipe.pl\n".
	"\n".
	"jabablast.pl -h TO GET FULL ARGUMENTS LIST.\n".
	"+-----------------------------+\n".
	"| REPEAT DATABASES            |\n".
	"+-----------------------------+\n".
	"gram_rep\n".
	"\tGramineae v3.1 repeat database from TIGR\n".
	"os_rep\n".
	"\tOryza sativa repeat database from TIGR\n".
	"RB_ath\n".
	"\tA. thaliana repeat database from RepBase\n".
	"RB_ory\n".
	"\tOryza sativa repeat database from RepBase\n".
	"RB_pln\n".
	"\tAll plants repeat database from RepBase\n".
	"TREP_8\n".
	"\tTREP v.8 database".
	"Wessler\n".
	"\tMAGI Wessler Repeat Database\n".
	"PM_TIR\n".
	"TIGRfab\n".
	"\tTIGR Fabaceae Repeat Database".
	"TIGRbras\n".
	"\tTIGR Brassiceae Repeat Database\n".
	"TIGRsol\n".
	"\tTIGR Solanaceae Repeat Database\n".
	"vector\n".
	"zm_rep\n".
	"\tZea mays repeat database from TIGR\n".
	"SanMiguel\n".
	"\tSanMiguel Repeat Database\n".
	"tigr_rice\n".
	"\tOryza sativa repeats from TIGR\n";
    
    print $FullUsage;

}

=head1 HISTORY
=cut
#-----------------------------------------------------------+
# HISTORY                                                   |
#-----------------------------------------------------------+
# 04/05/2007
#  - Started program
#  - Set general variable scope, added command line options
#  - Get root name using regexp and split
#  - System cmd for NCBI-BLAST formatdb
#  - System cmd for NCBI-BLAST All-by-All BLAST
#  
# 04/06/2007
#  - Create database if it does not exist 
#  - Running code to run the blast against the repeat 
#    databases. This function selected by the -R
#    boolean flag
#  - Added code to cat output from multipe repeat databases
#    to a single file 
#
# 04/11/2007
#  - Added the ability to get the user password from an
#    question based interface if it was not passed at
#    the command line.
